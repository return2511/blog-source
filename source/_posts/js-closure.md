---
title: 关于js闭包的解释
date: 2018-3-07
tags: [js,闭包]
categories: js
---

> 关于自己对js闭包的一点理解

<!-- more -->

#### 背景

一直以来都不敢说自己是一个前端，或者说是一个纯正的前端。总结了下，感觉自己会的东西很杂乱无章。关于计算机好多东西都有一点了解，但是往深了说，大部分东西又说不出个所以然来。很是感到惭愧。

痛定思痛，也是在我这次回归之前，下定了决心要把JavaScript给学好，不谈精通，因为知道自己还差的远。

前前后后看了很多js相关的书籍，总是在越看越觉得自己掌握的很少。也时常会感觉自己之前明明会的东西，可是过了一段时间之后，又有了很多遗忘。因此决定在这次重拾基础的过程中，多多动手记录。顺便充实自己的blog。

#### 初谈闭包（Closure）

- 首先闭包这个问题，相信但凡前端开发，面试中一定都被问到过。曾经在途牛那边面试过几个前端，我也把这个问题甩出去问过几个人。但是很遗憾，对于初级前端，我没有遇到几个能把闭包说的清清楚楚，明明白白的。
- 当然，我也不认为自己就能把这个问题讲的很明白，我是个可以接受错误的人，我希望未来有一天看到自己的代码会大骂，what the fk，这是什么玩意。我也希望自己有一天能改正本文中或许会出到的问题，个人拙见，如有错误，还望大家指正。

言归正传，js闭包这个问题。我相信所有前端jser第一次看到这个概念定义的时候，都是一脸懵逼状。。。这tm是什么玩意。

其实关于闭包一切还需要从作用域和变量生命周期（或者js垃圾回收机制）说起。

#### 作用域

js中存在两种变量：全局变量和局部变量。

- 在js中，函数内部是可以访问函数外部的变量的；

```javascript
var a = 100;
function ff() {
    console.log(a);
}
ff();//100  可以访问到外部的变量
```

但是如果在函数内部定义变量，外部却无法访问。

```javascript
function ff() {
    var a = 100 ;
}
console.log(a); // undefind  无法访问内部变量
```

关于作用域和变量提升的问题，抽时间再做另外介绍吧，本文先进行下面讲解。

#### 变量生命周期/垃圾回收机制

首先js局部变量是以函数为作用域区分的，如果函数执行完毕，js会有自己的垃圾回收机制，把当前执行完的作用域回收掉。高级语言都对应这自己的垃圾回收机制，主要用来防止内存泄漏。

因此变量的生命周期应该就只有其对应的函数执行的时间周期。过期作废。

#### 再谈闭包

那么js这门语言有没有一种方法是可以在外部也能访问到函数内部的变量呢？当然有，这就是我们今天的主题---闭包。

其实说的通俗点，我个人理解的闭包就是：通过使用闭包，可以使垃圾回收机制暂时不回收已经执行的函数作用域，进而可以在函数外部还能访问到内部的变量。（~~==对，我的理解之所以存在作用域，就是因为局部变量被回收了==~~ 回头看感觉这句话是错的）

多说无益，code奉上

```javascript
function ff() {
    var a = 100;
    return function(){
        console.log(a);
    }
}
var b = ff();
b();
```

通过如上代码，我们就可以在ff外面也能访问到ff内部的变量，并且进一步改造。

```javascript
function ff() {
    var a = 100;
    return function(){
        ++ a;
        console.log(a);
    }
}
var b = ff();
b(); // 101
b(); // 102
b(); // 103
```

可以发现，不仅可以访问到内部的变量，并且变量a再执行完b()之后也没有被释放掉。

- 解释：因为ff() 执行完毕之后返回一个内部function，并且该function使用了其外侧的变量a(是允许的)，但该function并没有执行，我们也无法预知其什么时候会执行（垃圾回收机制也要讲道理啊，要不然你把a给我回收了，我执行该function时候如果用到a咋办？）因此变量a将一直存在内存中。因此每次b()执行，变量a均会+1。

这就是所谓的闭包。

#### 使用闭包注意点

在刚刚的解释中，就存在一个问题。

- 由于我们无法预知闭包返回的function什么时候执行，所以闭包返回的变量将一直存在于内存中不会被释放。这也就无形中存在一个问题，如果在我们的代码中无节制的滥用闭包，那么就有可能存在内存泄漏的风险。

因此我们要在代码中养成良好的习惯，当b不再使用的时候，及时释放，也就释放了闭包出来的局部变量。

- 还存在一个问题，我们看到在上述代码中函数外部执行b();而改变了父函数内部的变量a的值，这个时候我们想到js的继承，如果父函数是一个obj，变量a是其私有变量，那么就存在被篡改的风险，因此使用闭包的时候要注意避免篡改私有变量，以至于造成无法预估的错误。

#### 一道js闭包思考题

曾经我用这道题给过面试者，也是我在网上发现的一道挺好的题目，[题目出处](https://www.cnblogs.com/xxcanghai/p/4991870.html/)

```javascript
function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?
var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?
//问:三行a,b,c的输出分别是什么？
```

#### 小结

好多知识感觉自己会，但好多的时候又是说不上来。勤记，勤动手，勤总结，才能更好的掌握。

多思考，多动手，不抱怨～
